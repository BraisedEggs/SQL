# 关系型数据数据库系统  RDBMS

## 二维表格的关系

#### 数据库管理系统  RDBMS

![数据库管理系统.png](assest/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.png)

#### 数据库 database

![数据库.png](assest/%E6%95%B0%E6%8D%AE%E5%BA%93.png)

---

*表,记录，字段*
===============

    1、  E-R(entity-relationship)/(实体--联系）
            实体集
            属性
            联系集
    2、  一个实体集（class）对应于数据库中的一个表（table），
        一个实体（instance）则对应于数据库表中的一行（row），也称为一条记录（record）。
        一个属性（attribute）对应于数据库表中的一列（column），也称为一个字段（field）。
        ORM 思想 （Object Relational Mapping）
            数据库中的一个表 《---》 java或者python 中的一个类
            表中的一条数据 《---》 java或者python 中的一个对象（实体）
            表中的一列数据 《---》 java或者python 中的一个字段/属性（field)

## *表的关系*

    1-1
    1-多
    多-多
    自我引用

### **一对一**

    在实际的开发中应用不多，因为一对一可以创建成一张表。
        举例：设计 学生表 ：学号、姓名、手机号码、班级、系别、身份证号码、家庭住址、籍贯、紧急联系人、...
    拆为两个表：两个表的记录是一一对应关系。
        1、基础信息表 （常用信息）：学号、姓名、手机号码、班级、系别
        2、档案信息表 （不常用信息）：学号、身份证号码、家庭住址、籍贯、紧急联系人、...
    两种建表原则：
        *外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一。
        *外键是主键：主表的主键和从表的主键，形成主外键关系。

![一对一.png](assest/%E4%B8%80%E5%AF%B9%E4%B8%80.png)

### **一对多**

    常见实例场景： 客户表和订单表 ， 分类表和商品表 ， 部门表和员工表 。
    举例：
        员工表：编号、姓名、...、所属部门
        部门表：编号、名称、简介
    一对多建表原则：在从表(多方)创建一个字段，字段作为外键指向主表(一方)的主键

![一对多01.png](assest/%E4%B8%80%E5%AF%B9%E5%A4%9A01.png)
![一对多02.png](assest/%E4%B8%80%E5%AF%B9%E5%A4%9A02.png)
![一对多03.png](assest/%E4%B8%80%E5%AF%B9%E5%A4%9A03.png)

### **多对多**

    要表示多对多关系，必须创建第三个表，该表通常称为 联接表 ，
    它将多对多关系划分为两个一对多关系。将这两个表的主键都插入到第三个表中。

![多对多.png](assest/%E5%A4%9A%E5%AF%B9%E5%A4%9A.png)

### **自我引用**

    要表示多对多关系，必须创建第三个表，该表通常称为 联接表 ，
    它将多对多关系划分为两个一对多关系。将这两个表的主键都插入到第三个表中。

![自我引用.png](assest/%E8%87%AA%E6%88%91%E5%BC%95%E7%94%A8.png)

# **第三章，基本的select语言**

## 1、SQL的分类

    DDL： 数据定义语言（操作表的结构）   CREATE:创建----ALTER:修改----DROP:删除----RENAME:改名----TRUNCATE:清空
    DML： 数据操作语言（操作表的数据）   INTER:插入----DELETE:删除----UPDATE:更新----SELECT:查询
    DCL： 数据控制语言（针对权限和事务的控制）  COMMIT:提交----ROLLBACK：回滚----SAVEPOINT:保存节点----GRANT:赋予----REVOKE:撤销

## 2、SQL语言的规则和规范

### 2.1、规则

* 1、多条语句执行，前面的语句需要加分号，最后一个可加可不加（一条语句执行可加可不加）
* 2、SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进
* 3、每条命令以 ; 或 \g 或 \G 结束
* 4、关键字不能被缩写也不能分行
* 5、关于标点符号
    + a、必须保证所有的()、单引号、双引号是成对结束的
    + b、必须使用英文状态下的半角输入方式
    + c、字符串型和日期时间类型的数据可以使用单引号（' '）表示
    + d、列的别名，尽量使用双引号（" "），而且不建议省略as

### 2.2、SQL大小写规范 （建议遵守）

#### 1、MySQL 在 Windows 环境下是大小写不敏感的

#### 2、MySQL 在 Linux 环境下是大小写敏感的

    数据库名、表名、表的别名、变量名是严格区分大小写的
    关键字、函数名、列名(或字段名)、列的别名(字段的别名) 是忽略大小写的。

#### 3、推荐采用统一的书写规范：

    数据库名、表名、表别名、字段名、字段别名等都小写
    SQL 关键字、函数名、绑定变量等都大写

### 2.3、注释

        单行注释：#注释文字(MySQL特有的方式)
        单行注释：-- 注释文字(--后面必须包含一个空格。)
        多行注释：/* 注释文字 */

### 2.4、命名规则

* 数据库、表名不得超过30个字符，变量名限制为29个
* 必须只能包含 A–Z, a–z, 0–9, _共63个字符
* 数据库名、表名、字段名等对象名中间不要包含空格
* 同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名
* 必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使 用`（着重号）引起来
* 保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据 类型在一个表里是整数，那在另一个表里可就别变成字符型了

# 查询

## 1、导入

* 方法1： source 文件的全部路劲
* 方法2： 基于具体的图形化界面工具可以导入数据

## 2、基本查询语句

### SELECT 字段1,字段2,... FROM 表名

#### 例如：

* SELECT * FROM employees
* SELECT employee_id,last_name,salary FROM employees

### 注意点

* 伪表 FROM DUAL ===> # dual：伪表

## 3、列的别名

* as：全称：alias(别名)，可以省略
* 列的别名可以使用一对""引起来--------不要使用单引号‘’

#### 例如：

* SELECT employee_id emp_id,last_name AS Lname,salary "工资" FROM employees
* SELECT employee_id emp_id,last_name AS Lname,salary "工资" salary * 12 "annual sal" FROM employees

## 4、去重重复行(去重)

#### 问题：

查询员工表中一共有哪些部门ID

### 错误的(没有去重)

* SELECT department_id FROM employess

### 正确的(去重)

* SELECT DISTINCT department_id FROM employess
* SELECT DISTINCT department_id, salary FROM employees (联合去重没有实际意义)

## 4、空值参与运算

#### 空值： NULL

#### NULL 不等于 0 '' 'null'

#### 空值参与运算  结果也一定为空

* SELECT employee_id "员工ID",salary "月工资",salary * (1 + commission_pct) *12 "年工资" FROM employees
* 解决方法： 使用IFNULL(不为空的值,为空的值) -----实际问题解决方案
    * SELECT employee_id "员工ID",salary "月工资",salary * (1 + IFNULL(commission_pct,0)) *12 "年工资" FROM employees

## 5、着重号 ``

#### 出现和保留字、数据库系统或常用方法字段一样  需要使用 `` 包裹

#### 例如： order是关键字

* SELECT * FROM `order`

## 6、查询常数

* SELECT "SQL公司", employee_id "员工ID",salary "月工资",salary * (1 + IFNULL(commission_pct,0)) *12 "年工资" FROM
  employees

## 7、显示表结构

#### 注意可能报错 有两种写法

* DESC employees
* DESCRIBE employees

## 8、过滤数据

* 声明在FROM后面

#### 查询90号部门的员工信息

* SELECT * FROM employees WHERE department_id = 90

#### 查询last_name为king的员工信息

* SELECT * FROM employees WHERE last_name = 'king'

# 运算符

## 1、算数运算符

### + ===> 加

### - ===> 减

###                                                                       * ===> 乘

### (/ div) ===> 除

### (% mod) ===> 取余

### 例子

* 在SQL中，+没有连接的作用，就表示加法运算。此时，会将字符串转换为数值（隐式转换）
* SELECT 100 + '1' FROM DUAL; # 在Java语言中，结果是：1001。
* SELECT 100 + 'a' FROM DUAL; #此时将'a'看做0处理
* SELECT 100 + NULL FROM DUAL; # null值参与运算，结果为null
* SELECT 100, 100 * 1, 100 * 1.0, 100 / 1.0, 100 / 2,
  100 + 2 * 5 / 2,100 / 3, 100 DIV 0 # 分母如果为0，则结果为null
  FROM DUAL;

### 取模运算： % mod

* SELECT 12 % 3,12 % 5, 12 MOD -5,-12 % 5,-12 % -5 FROM DUAL;
* 取模运算的符号和被膜数有关 和膜数无关

### 注意点

* 一个整数类型的值对整数进行加法和减法操作，结果还是一个整数；
* 一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数；
* 加法和减法的优先级相同，进行先加后减操作与进行先减后加操作的结果是一样的；
* 在Java中，+的左右两边如果有字符串，那么表示字符串的拼接。但是在MySQL中+只表示数
  值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按0计算。（补充：MySQL
  中字符串拼接要使用字符串函数CONCAT()实现）

## 2、比较运算符

#### 比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回1，比较的结果为假则返回0，其他情况则返回NULL。

![比较运算符.png](assest/%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6.png)

### 2.1、等号运算符

* 等号运算符（=）判断等号两边的值、字符串或表达式是否相等，如果相等则返回1，不相等则返回 0.
* 在使用等号运算符时，遵循如下规则：

    - 如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的
    - 是每个字符串中字符的ANSI编码是否相等。
    - 如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小。
    - 如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较。
    - 如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL。
* 字符串存在隐式转换。如果转换数值不成功，则看做0
    * SELECT 1 = 2,1 != 2,1 = '1',1 = 'a',0 = 'a' FROM DUAL;
* 两边都是字符串的话，则按照ANSI的比较规则进行比较。
    * SELECT 'a' = 'a','ab' = 'ab','a' = 'b' FROM DUAL;
* 只要有null参与判断，结果就为null
    * SELECT 1 = NULL,NULL = NULL FROM DUAL;
    * SELECT last_name,salary,commission_pct
      FROM employees
      #where salary = 6000;
      WHERE commission_pct = NULL; #此时执行，不会有任何的结果

### 2.1、安全等于运算符 <=>

#### 安全等于运算符(<=>)与等于运算符(=)的作用是相似的，唯一的区别 是<=>'可以用来对NULL进行判断。在两个操作数均为NULL时，其返回值为1，而不为NULL;当一个操作数为NULL时，其返回值为0，而不为NULL。

* SELECT 1 <=> 2,1 <=> '1',1 <=> 'a',0 <=> 'a' FROM DUAL;
* SELECT 1 <=> NULL, NULL <=> NULL FROM DUAL; ===》0/1

#### 练习：查询表中commission_pct为null的数据有哪些

* SELECT last_name,salary,commission_pct FROM employees WHERE commission_pct <=> NULL;

### 2.3、其余

* SELECT 3 <> 2,'4' <> NULL, '' != NULL,NULL != NULL
  FROM DUAL;

### 2.4、非符号运算符

#### 2.4.1、IS NULL \ IS NOT NULL \ ISNULL

##### 练习：查询表中commission_pct为null的数据有哪些

* SELECT last_name,salary,commission_pct
  FROM employees
  WHERE commission_pct IS NULL;
  #或
  SELECT last_name,salary,commission_pct
  FROM employees
  WHERE ISNULL(commission_pct);

##### 练习：查询表中commission_pct不为null的数据有哪些

* SELECT last_name,salary,commission_pct
  FROM employees
  WHERE commission_pct IS NOT NULL;
  #或
  SELECT last_name,salary,commission_pct
  FROM employees
  WHERE NOT commission_pct <=> NULL;

#### 2.4.2、LEAST() \ GREATEST

* SELECT LEAST('g','b','t','m'),GREATEST('g','b','t','m')
  FROM DUAL;
* SELECT LEAST(first_name,last_name),LEAST(LENGTH(first_name),LENGTH(last_name))
  FROM employees;

#### 2.4.3、BETWEEN 条件下界1 AND 条件上界2 （查询条件1和条件2范围内的数据，包含边界）

##### 查询工资在6000 到 8000的员工信息

* SELECT employee_id,last_name,salary
  FROM employees
  #where salary between 6000 and 8000;
  WHERE salary >= 6000 && salary <= 8000;

##### 查询工资不在6000 到 8000的员工信息

* SELECT employee_id,last_name,salary
  FROM employees
  WHERE salary NOT BETWEEN 6000 AND 8000;
  #where salary < 6000 or salary > 8000;

#### 2.4.4、 #④ in (set)\ not in (set)----离散值的查找

##### 练习：查询部门为10,20,30部门的员工信息

* SELECT last_name,salary,department_id
  FROM employees
  #where department_id = 10 or department_id = 20 or department_id = 30;
  WHERE department_id IN (10,20,30);

##### 练习：查询工资不是6000,7000,8000的员工信息

* SELECT last_name,salary,department_id
  FROM employees
  WHERE salary NOT IN (6000,7000,8000);

#### 2.4.5、LIKE :模糊查询

* % : 代表不确定个数的字符 （0个，1个，或多个）--忽略大小写
* _ ：代表一个不确定的字符
* \ : 转义字符

##### 练习：查询last_name中包含字符'a'的员工信息

* SELECT last_name
  FROM employees
  WHERE last_name LIKE '%a%';

##### 练习：查询last_name中包含字符'a'的员工信息

* SELECT last_name
  FROM employees
  WHERE last_name LIKE 'a%';

##### 练习：查询last_name中包含字符'a'且包含字符'e'的员工信息

* 写法1：
  SELECT last_name
  FROM employees
  WHERE last_name LIKE '%a%' AND last_name LIKE '%e%';
* 写法2：
  SELECT last_name
  FROM employees
  WHERE last_name LIKE '%a%e%' OR last_name LIKE '%e%a%';

##### 练习：查询第3个字符是'a'的员工信息

* SELECT last_name
  FROM employees
  WHERE last_name LIKE '__a%';

##### 练习：查询第2个字符是_且第3个字符是'a'的员工信息

* 需要使用转义字符: \
  SELECT last_name
  FROM employees
  WHERE last_name LIKE '_\_a%';

* 或者  (了解)
  SELECT last_name
  FROM employees
  WHERE last_name LIKE '_$_a%' ESCAPE '$';

#### 2.4.6、REGEXP \ RLIKE :正则表达式

* （1）‘^’匹配以该字符后面的字符开头的字符串。
* （2）‘$’匹配以该字符前面的字符结尾的字符串。
* （3）‘.’匹配任何一个单字符。
* （4）“[...]”匹配在方括号内的任何字符。例如，“[abc]”匹配“a”或“b”或“c”。为了命名字符的范围，使用一
  个‘-’。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。
* （5）‘*’匹配零个或多个在它前面的字符。例如，“x*”匹配任何数量的‘x’字符，“[0-9]*”匹配任何数量的数字，
  而“*”匹配任何数量的任何字符。

SELECT 'shkstart' REGEXP '^shk', 'shkstart' REGEXP 't$', 'shkstart' REGEXP 'hk'
FROM DUAL;

SELECT 'atguigu' REGEXP 'gu.gu','atguigu' REGEXP '[ab]'
FROM DUAL;

## 3、逻辑运算符： OR || AND && NOT ! XOR

- 注意：OR可以和AND一起使用，但是在使用时要注意两者的优先级，由于AND的优先级高于OR，因此先
  对AND两边的操作数进行操作，再与OR中的操作数结合。

### or  and

* SELECT last_name,salary,department_id
  FROM employees
  #where department_id = 10 or department_id = 20;
  #where department_id = 10 and department_id = 20;
  WHERE department_id = 50 AND salary > 6000;

### not

* SELECT last_name,salary,department_id
  FROM employees
  #where salary not between 6000 and 8000;
  #where commission_pct is not null;
  WHERE NOT commission_pct <=> NULL;

### XOR :追求的"异"

* SELECT last_name,salary,department_id
  FROM employees
  WHERE department_id = 50 XOR salary > 6000;

## 4、位运算符： & | ^  ~  >>   <<

![逻辑运算.png](assest/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97.png)

## 5、运算符的优先级

## 6、正则表达式

# 排序与分类

## 1、排序

* 使用 ORDER BY 对查询到的数据进行排序操作。
* 升序：ASC (ascend)
* 降序：DESC (descend)

#### 练习：按照salary从高到低的顺序显示员工信息

* SELECT employee_id,last_name,salary
  FROM employees
  ORDER BY salary DESC;

#### 练习：按照salary从低到高的顺序显示员工信息

* SELECT employee_id,last_name,salary
  FROM employees

### 我们可以使用列的别名，进行排序

* SELECT employee_id,salary,salary * 12 annual_sal
  FROM employees
  ORDER BY annual_sal;

### 注意点

* 列的别名只能在 ORDER BY 中使用，不能在WHERE中使用。
* 如下操作报错！
  SELECT employee_id,salary,salary * 12 annual_sal
  FROM employees
  WHERE annual_sal > 81600;
  ![select数据流程.png](assest/select%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B.png)

### 强调格式：WHERE 需要声明在FROM后，ORDER BY之前。

* SELECT employee_id,salary
  FROM employees
  WHERE department_id IN (50,60,70)
  ORDER BY department_id DESC;

### 二级排序

#### 练习：显示员工信息，按照department_id的降序排列，salary的升序排列

* SELECT employee_id,salary,department_id
  FROM employees
  ORDER BY department_id DESC,salary ASC;

## 2、分页

### 需求：每页显示pageSize条记录，此时显示第pageNo页：

### 公式：LIMIT (pageNo-1) * pageSize,pageSize;

#### 需求1：每页显示20条记录，此时显示第1页

* SELECT employee_id,last_name
  FROM employees
  LIMIT 0,20;

#### 需求2：每页显示20条记录，此时显示第2页

* SELECT employee_id,last_name
  FROM employees
  LIMIT 20,20;

#### 需求3：每页显示20条记录，此时显示第3页

* SELECT employee_id,last_name
  FROM employees
  LIMIT 40,20;

### *WHERE ... ORDER BY ...LIMIT 声明顺序如下*

#### LIMIT的格式： 严格来说：LIMIT 位置偏移量,条目数

#### 结构"LIMIT 0,条目数" 等价于 "LIMIT 条目数"

* SELECT employee_id,last_name,salary
  FROM employees
  WHERE salary > 6000
  ORDER BY salary DESC
  #limit 0,10;
  LIMIT 10;

#### 练习：表里有107条数据，我们只想要显示第 32、33 条数据怎么办呢？

* SELECT employee_id,last_name
  FROM employees
  LIMIT 31,2;

### 新特性  MySQL8.0新特性：LIMIT ... OFFSET ...

#### 练习：表里有107条数据，我们只想要显示第 32、33 条数据怎么办呢？

* SELECT employee_id,last_name
  FROM employees
  LIMIT 2 OFFSET 31;

#### 练习：查询员工表中工资最高的员工信息

* SELECT employee_id,last_name,salary
  FROM employees
  ORDER BY salary DESC
  #limit 0,1
  LIMIT 1;

### 其他数据库拓展
![其他数据库拓展分页.png](assest/%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8B%93%E5%B1%95%E5%88%86%E9%A1%B5.png)
![其他数据库拓展分页1.png](assest/%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8B%93%E5%B1%95%E5%88%86%E9%A1%B51.png)




